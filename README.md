## JSX + ES6 문법 살펴보기

### Template String (템플릿 문자열)

* 템플릿 문자열은 문자열 안에 변수와 연산식을 혼합하여 사용합니다

#### 02-2.js 안의 세부 내용

* 병합 연산자를 사용해 문자열과 문자열을 연결하고 있습니다.
* 문자열과 변수를 연결할 경우에도 병합 연산자를 사용합니다
* 줄바꿈을 할 경우에는 이스케이프 시퀀스(\n)을 문자열에 포함시킵니다
* 연산 결과를 괄호로 묶어 연산 구문을 먼저 실행하기도 합니다

#### 템플릿 문자열

* 병합 연산자를 사용하니 코드가 복잡해 보입니다. ES6 문법은 해당 내용을 개선하기 위해 **템플릿 문자열**을 도입했습니다
* 작은 따옴표 대신 백틱으로 문자열을 표현하는 것이 템플릿 문자열입니다.

#### 02-2.js 안의 세부 내용

* 템플릿 문자열에 $ 기호를 사용하여 변수를 포함하였습니다
* 템플릿 문자열은 enter 키를 눌러 줄을 바꾸는 것도 허용합니다
* 이스케이프 시퀀스를 사용하지 않아도 됩니다
* $ 기호를 이용해여 연산을 포함시킬 수도 있습니다


### Spread Operator (전개 연산자)

* ES6의 전개 연산자는 독특하면서도 매우 유용한 문법입니다.
* 전개연산자는 나열형 자료를 추출하거나 연결할 경우 사용합니다
* 객체, 변수명 앞에 ... 마침표 3개를 입력하면 됩니다
* 다만 배열 객체 함수 인자 표현식 안에서만 사용해야 합니다.

#### 02-3.js 안의 세부 내용

* 배열의 각 요소를 추출하여 새로운 배열을 만들었습니다
* concat 함수로 두 배열을 합쳤습니다.
* index로 배열 요소를 추출했습니다
* || 연산자와 조합하면 추출할 배열 요소가 없을 경우 기본 값을 지정할 수 있습니다.
* 특수 변수를 사용해 함수 내 인자 항목들을 배열로 변환하였습니다
* index 범위에 해당하는 배열 요소를 추출합니다

#### 전개 연산자는 객체에서도 사용가능합니다. 

### 클래스

* 기존 자바스크립트 문법은 클래스 표현식이 없어서 prototype으로 클래스를 표현했습니다.
* ES6에서는 클래스를 정의하여 사용할 수 있습니다.
* 자바스크립트에서 기존 클래스 표현방법은 함수를 생성자(constructor) 형태로 선언한 다음 상속이 필요한 변수나 함수를 prototype 객체에 할당하는 방법을 사용했습니다.
* prototype 객체는 new 연산자로 생성되는 객체 안에서 this 연산자의 함수 및 변수 선언 위치를 참조할 수 있는 요소인데, 이 특성을 이용한 것입니다

#### 02-6.js 안의 세부 내용

* new Shape(0,0)와 같이 함수를 호출하면 this 객체에 변수 및 함수가 prototype 객체에 선언된 변수와 함수를 함께 참조합니다.
* 예를들어 Shape() 생성자 함수에는 this.move에 함수를 정의하지 않았지만 prototype 객체에 move() 함수가 정의 되어있으므로 prototype 선언 이후 new 연산자로 Shape() 함수를 호출한 뒤 객체 s를 만듭니다.
* 그 만든 s 객체는 move 함수를 참조가능하게 됩니다

#### ES6 클래스 문법을 사용해보면?

* class 키워드로 클래스를 정의하므로 코드가 훨씬 간결해집니다.
* 해당 Class 함수 코드는 ES7에 포함된 클래스 확장 표현으로 constructor 함수 안에 this.name = "Shape"로 클래스 변수를 선언하는 것과 동일한 작업을 수행합니다.

#### 보면 볼수록 기존 언어의 패턴과 유사하네요.
